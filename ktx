#!/usr/bin/env bash

# Author: Deac Karns
# Date: 10/09/2024
# Description: A simple script to switch between kubectl contexts and versions, and to download new versions of kubectl.

# Version
KTX_VERSION="0.5.2"

red=$(tput setaf 1)
gold=$(tput setaf 3)
blue=$(tput setaf 4)
magenta=$(tput setaf 5)
cyan=$(tput setaf 6)
default=$(tput sgr0)

bin_dir=$HOME/.kube/kubectl/bin

symlink_dir=.kube/kubectl
symlink_path=$HOME/$symlink_dir

echo "â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—"
echo "â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•"
echo "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•‘    â•šâ–ˆâ–ˆâ–ˆâ•”â• "
echo "â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— "
echo "â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—"
echo "â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•"
echo -e "${gold}Kubectl Context Switcher\n\n${default}"

function check_dependencies() {
  if ! command -v jq &> /dev/null; then
    echo -e "${red}Error: jq is required but not installed.${default}"
    echo -e "${cyan}Please install jq to use this script:${default}"
    echo -e "${cyan}  macOS: brew install jq${default}"
    echo -e "${cyan}  Ubuntu/Debian: sudo apt-get install jq${default}"
    echo -e "${cyan}  CentOS/RHEL: sudo yum install jq${default}"
    kill -INT $$
  fi
}

function check_version() {
  # Check for updates (non-blocking, with timeout)
  local latest_version
  latest_version=$(curl -s --max-time 5 "https://api.github.com/repos/peledies/ktx/releases/latest" 2>/dev/null | \
    jq -r '.tag_name' 2>/dev/null | \
    sed 's/^v//' 2>/dev/null)

  # Only show message if we successfully got a version and it's different
  if [[ -n "$latest_version" && "$latest_version" != "null" && "$latest_version" != "$KTX_VERSION" ]]; then
    echo -e "${gold}ðŸ“¦ Update available: ${magenta}v$latest_version${gold} (current: ${cyan}v$KTX_VERSION${gold})${default}"
    echo -e "${cyan}   Run: ${magenta}brew upgrade ktx${cyan} to update${default}\n"
  fi
}

function setup_profile() {
  local profile_file=""
  local profile_options=("~/.zshrc" "~/.bash_profile" "~/.bashrc" "Enter custom path")

  echo -e "${gold}Which profile file would you like to configure?${default}"
  echo -e "${cyan}Current shell: ${magenta}$SHELL${default}\n"

  PS3="${cyan}Select profile file: $gold"
  select profile_choice in "${profile_options[@]}"; do
    case "$profile_choice" in
      "~/.zshrc")
        profile_file="$HOME/.zshrc"
        break
        ;;
      "~/.bash_profile")
        profile_file="$HOME/.bash_profile"
        break
        ;;
      "~/.bashrc")
        profile_file="$HOME/.bashrc"
        break
        ;;
      "Enter custom path")
        read -p "${cyan}Enter the full path to your profile file: ${default}" custom_path
        # Expand tilde if present
        profile_file="${custom_path/#\~/$HOME}"
        break
        ;;
      "")
        echo "${red}Invalid Option${default}"
        ;;
      *)
        echo "${red}Invalid selection${default}"
        ;;
    esac
  done

  local path_line="PATH=\$HOME/.kube/kubectl:\$PATH"
  local kubeconfig_line="export KUBECONFIG=\$(find ~/.kube -name 'config*' | sort | tr '\n' ':')"
  local path_comment="# KTX - Kubectl versions installed with ktx"
  local kubeconfig_comment="# KTX - Load all the config files in the .kube directory"

  local changes_made=false

  # Create profile file if it doesn't exist
  if [[ ! -f "$profile_file" ]]; then
    touch "$profile_file"
    echo -e "${cyan}Created profile file: ${magenta}$profile_file${default}"
  fi

  # Check and add PATH configuration
  if ! grep -Fq "$path_line" "$profile_file"; then
    echo -e "${cyan}Adding kubectl PATH configuration to ${magenta}$profile_file${default}"
    echo "" >> "$profile_file"
    echo "$path_comment" >> "$profile_file"
    echo "$path_line" >> "$profile_file"
    changes_made=true
  fi

  # Check and add KUBECONFIG configuration
  if ! grep -Fq "$kubeconfig_line" "$profile_file"; then
    echo -e "${cyan}Adding KUBECONFIG configuration to ${magenta}$profile_file${default}"
    echo "" >> "$profile_file"
    echo "$kubeconfig_comment" >> "$profile_file"
    echo "$kubeconfig_line" >> "$profile_file"
    changes_made=true
  fi

  if [[ "$changes_made" == true ]]; then
    echo -e "${gold}Profile configuration updated successfully!${default}"
    echo -e "${cyan}Please run ${magenta}source $profile_file${cyan} or restart your terminal to apply changes.${default}"
  else
    echo -e "${gold}Profile is already configured correctly.${default}"
  fi
}

function verify_path() {
  if [[ ":$PATH:" != *":$symlink_path:"* ]]; then
    echo -e "${red}The directory $symlink_path is not in your PATH.${default}"
    echo -e "${gold}Would you like ktx to automatically configure your profile? (y/n)${default}"
    read -r response

    if [[ "$response" =~ ^[Yy]$ ]]; then
      setup_profile
      echo -e "${cyan}Please restart your terminal or re-source your profile file and try again.${default}"
    else
      echo -e "${gold}You need to manually add the following to your PATH:\n - ${magenta}\$HOME/$symlink_dir${default}"
    fi

    kill -INT $$
  fi
}

function verify_symlink() {
  if [ ! -L $symlink_path/kubectl ]; then
    echo -e "${red}kubectl symlink does not exist. \nLets get you a version of kubectl${default}"
    kubectl_manage
    kill -INT $$
  fi
}

function switch_context() {

  CONTEXTS=( $(kubectl config get-contexts | awk 'NR!=1''{print $2}') )

  if [ ${#CONTEXTS[@]} -eq 0 ]; then
    echo -e "${red}No kubectl contexts found${default}"
    return
  fi

  # Check if fzf is installed
  if command -v fzf &> /dev/null; then
    # Use fzf for context selection
    local context
    context=$(printf '%s\n' "${CONTEXTS[@]}" | fzf --height=50% --reverse --prompt="Select Context: ")

    if [ -n "$context" ]; then
      kubectl config use-context "$context" > /dev/null
      echo "${gold}Kubectl Context switched to ${magenta}$context${default}"
    fi
    return
  fi

  # Fallback to original menu-based selection if fzf is not installed
  local filtered_contexts=("${CONTEXTS[@]}")
  local search_term=""

  while true; do
    echo -e "\n${gold}Available contexts${default}${cyan}${search_term:+ (filtered by: '$search_term')}${default}${gold}:${default}"

    # Add filter option as the first item (0th option)
    local menu_options=("--- Filter contexts ---" "${filtered_contexts[@]}")

    PS3="${cyan}Select a kubectl context (1 to filter): $gold"
    select context in "${menu_options[@]}"; do
      case "$context" in
        "")
          echo "${red}Invalid Option ${magenta}CTL + C to quit${default}"
          ;;
        "--- Filter contexts ---")
          echo -e "${cyan}Type to filter contexts (ESC to finish, Backspace to delete):${default}"
          search_term=""

          while true; do
            # Clear previous output
            tput clear

            # Show current filter term
            echo -e "${cyan}Filter: ${magenta}$search_term${default}"
            echo -e "${cyan}Type to filter contexts (ESC to finish, Backspace to delete):${default}\n"

            # Filter contexts based on current search term
            filtered_contexts=()
            if [[ -z "$search_term" ]]; then
              filtered_contexts=("${CONTEXTS[@]}")
            else
              for ctx in "${CONTEXTS[@]}"; do
                # Convert both to lowercase for case insensitive comparison
                if [[ "${ctx,,}" == *"${search_term,,}"* ]]; then
                  filtered_contexts+=("$ctx")
                fi
              done
            fi

            # Show filtered results list
            if [ ${#filtered_contexts[@]} -eq 0 ]; then
              echo -e "${red}No matching contexts${default}"
            else
              echo -e "${gold}Matching contexts:${default}"
              for i in "${!filtered_contexts[@]}"; do
                # Highlight the matching part in the context name
                ctx="${filtered_contexts[$i]}"
                if [[ -n "$search_term" ]]; then
                  # Use sed to highlight the matching substring (case insensitive)
                  highlighted=$(echo "$ctx" | sed -E "s/($search_term)/${magenta}\1${default}/gI")
                  echo -e " $highlighted"
                else
                  echo -e " ${magenta}$ctx${default}"
                fi
              done
            fi

            # Read single character
            read -rsn1 char

            case "$char" in
              $'\e')  # ESC key - exit filter mode
                echo -e "\n${cyan}Filter applied: '${magenta}$search_term${cyan}'${default}"
                break
                ;;
              $'\177'|$'\b')  # Backspace or Delete
                if [[ ${#search_term} -gt 0 ]]; then
                  search_term="${search_term%?}"
                fi
                ;;
              '')  # Enter key - also exit filter mode
                echo -e "\n${cyan}Filter applied: '${magenta}$search_term${cyan}'${default}"
                break
                ;;
              *)  # Regular character
                if [[ "$char" =~ [[:print:]] ]]; then
                  search_term+="$char"
                fi
                ;;
            esac

          done

          # Final filter application
          if [[ -n "$search_term" ]]; then
            filtered_contexts=()
            for ctx in "${CONTEXTS[@]}"; do
              if [[ "${ctx,,}" == *"${search_term,,}"* ]]; then
                filtered_contexts+=("$ctx")
              fi
            done

            if [ ${#filtered_contexts[@]} -eq 0 ]; then
              echo "${red}No contexts found matching '$search_term'${default}"
              filtered_contexts=("${CONTEXTS[@]}")
              search_term=""
            fi
          else
            filtered_contexts=("${CONTEXTS[@]}")
          fi
          break
          ;;
        *)
          # Check if it's a valid context (not a menu option)
          if [[ " ${CONTEXTS[@]} " =~ " ${context} " ]]; then
            kubectl config use-context "$context" > /dev/null
            echo "${gold}Kubectl Context switched to ${magenta}$context${default}"
            return
          else
            echo "${red}Invalid selection${default}"
          fi
          ;;
      esac
    done
  done
}

function kubectl_manage() {
  # Get list of already installed versions
  local installed_versions=()
  if [ -d "$bin_dir" ] && [ "$(ls -A $bin_dir 2>/dev/null)" ]; then
    local files=("$bin_dir"/*)
    for file in "${files[@]}"; do
      if [ -f "$file" ]; then
        installed_versions+=("${file##*/}")
      fi
    done
  fi

  # Display installed versions if any exist
  if [ ${#installed_versions[@]} -gt 0 ]; then
    echo -e "\n${gold}Currently installed kubectl versions:${default}"
    for version in $(printf '%s\n' "${installed_versions[@]}" | sort -V -r); do
      # Check if this version is currently active
      if [ -L "$symlink_path/kubectl" ]; then
        current_version=$(readlink "$symlink_path/kubectl")
        current_version=${current_version##*/}
        if [[ "$version" == "$current_version" ]]; then
          echo -e "  ${magenta}$version${default} ${cyan}(active)${default}"
        else
          echo -e "  ${magenta}$version${default}"
        fi
      else
        echo -e "  ${magenta}$version${default}"
      fi
    done
    echo ""
  fi

  # Fetch available versions from GitHub
  echo -e "${cyan}Fetching available kubectl versions...${default}"
  local online_releases=$(curl -s --max-time 10 "https://api.github.com/repos/kubernetes/kubernetes/releases?per_page=30" | \
    jq -r '.[] | select(.prerelease == false) | .tag_name' 2>/dev/null | \
    head -10 | \
    sort -V -r)

  # Build the selection menu
  local options=()
  local option_types=()

  # Add installed versions for switching
  if [ ${#installed_versions[@]} -gt 0 ]; then
    options+=("=== SWITCH TO INSTALLED VERSION ===")
    option_types+=("header")
    for version in $(printf '%s\n' "${installed_versions[@]}" | sort -V -r); do
      options+=("$version")
      option_types+=("installed")
    done
  fi

  # Add online versions
  if [[ -n "$online_releases" ]]; then
    options+=("=== DOWNLOAD NEW VERSIONS ===")
    option_types+=("header")
    while IFS= read -r version; do
      # Check if this version is already installed
      version_clean=${version#v}
      if [[ ! " ${installed_versions[@]} " =~ " v${version_clean} " ]]; then
        options+=("$version")
        option_types+=("download")
      fi
    done <<< "$online_releases"
  fi

  # Add manual entry option
  options+=("=== OTHER OPTIONS ===")
  option_types+=("header")
  options+=("Enter custom version")
  option_types+=("custom")

  if [ ${#options[@]} -eq 0 ]; then
    echo "${red}No kubectl versions found. Please check your setup.${default}"
    kill -INT $$
  fi

  echo -e "${gold}Select kubectl version to use or download:${default}"
  PS3="${cyan}Select version: $gold"
  select opt in "${options[@]}"; do
    case "$opt" in
      "")
        echo "${red}Invalid Option ${magenta}CTL + C to quit${default}"
        ;;
      "=== SWITCH TO INSTALLED VERSION ===" | "=== DOWNLOAD NEW VERSIONS ===" | "=== OTHER OPTIONS ===")
        echo "${cyan}Please select a specific version${default}"
        ;;
      "Enter custom version")
        read -p "${cyan}Enter the kubectl version to get (e.g., 1.29.0): ${default}" custom_version
        # Validate custom version format
        if [[ ! "$custom_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
          echo "${red}Invalid version format. Please use format like: 1.29.0${default}"
          continue
        fi
        version="v${custom_version}"
        action="download"
        break
        ;;
      *)
        # Determine if this is an installed version or download version
        if [[ " ${installed_versions[@]} " =~ " ${opt} " ]]; then
          version="$opt"
          action="switch"
        else
          version="$opt"
          action="download"
        fi
        break
        ;;
    esac
  done

  version_clean=${version#v}

  if [[ "$action" == "switch" ]]; then
    # Switch to already installed version
    echo "kubectl set to version: ${magenta}$version${default}"
    ln -nsf $bin_dir/$version $symlink_path/kubectl
    echo -e "${gold}kubectl $version is now active!${default}"
    return
  fi

  # Download new version
  echo "${magenta}You have selected kubectl version: ${version}${default}"

  if [[ $(uname -m) == "x86_64" ]]; then
    echo "${cyan}Detected architecture: amd64${default}"
    arch="amd64"
  elif [[ $(uname -m) == "arm64" ]]; then
    echo "${cyan}Detected architecture: arm64${default}"
    arch="arm64"
  else
    echo "${red}Unsupported architecture. Use amd64 or arm64${default}"
    kill -INT $$
  fi

  if [[ $(uname) == "Darwin" ]]; then
    echo "${cyan}Detected OS: macOS${default}"
    os="darwin"
  elif [[ $(uname) == "Linux" ]]; then
    echo "${cyan}Detected OS: Linux${default}"
    os="linux"
  else
    echo "${red}Unsupported OS. Use Mac or Linux${default}"
    kill -INT $$
  fi

  mkdir -p $bin_dir

  echo -e "${cyan}Downloading kubectl version: ${magenta}${version}${default}"

  # Check if download is successful
  if curl -Ls --max-time 30 "https://dl.k8s.io/release/v${version_clean}/bin/${os}/${arch}/kubectl" -o $bin_dir/v${version_clean}; then
    echo -e "${cyan}Download successful!${default}"
  else
    echo "${red}Download failed. Please check the version and try again.${default}"
    rm -f $bin_dir/v${version_clean}
    kill -INT $$
  fi

  echo -e "${cyan}Creating symlink to kubectl version: ${magenta}${version}${default}"
  ln -nsf $bin_dir/v${version_clean} $symlink_path/kubectl

  echo -e "${cyan}Setting execute permissions for kubectl${default}"
  chmod +x $symlink_path/kubectl

  echo -e "${gold}kubectl ${version} has been successfully installed and is now active!${default}"
}

function kubectl_pull() {

  # this is the "folder" in lastpass
  NAMESPACE="kubernetes-configs"

  IDS=$(lpass show -xjG '.*' | jq --raw-output '.[] | select( .group == "'$NAMESPACE'" ) | select(.url != "http://group" ) | .id')

  echo -e "\n${cyan}Creating the following kube config files in ${magenta}$HOME/.kube${cyan}:${default}\n"

  for ID in $IDS
  do
    NAME=$(lpass show $ID --name)
    printf "%-40s %s\n" "$NAME" "${magenta}$ID${default}"
    CONFIG="$(lpass show $ID --notes)"

    echo "$CONFIG" > $HOME/.kube/config-$NAME
  done
}

function verify_kubeconfig() {
  # Check if KUBECONFIG is set in the environment using env command
  local kubeconfig_env=$(env | grep "^KUBECONFIG=")

  if [[ -z "$kubeconfig_env" ]]; then
    echo -e "${red}KUBECONFIG is not configured to load all config files from ~/.kube${default}"
    echo -e "${gold}Would you like ktx to automatically configure your profile? (y/n)${default}"
    read -r response

    if [[ "$response" =~ ^[Yy]$ ]]; then
      setup_profile
      echo -e "${cyan}Please restart your terminal or re-source your profile file and try again.${default}"
      kill -INT $$
    else
      echo -e "${gold}You need to manually add the KUBECONFIG configuration to your profile.${default}"
      echo -e "${cyan}Add this line to your ~/.zshrc, ~/.bash_profile, or ~/.bashrc:${default}"
      echo -e "${magenta}export KUBECONFIG=\$(find ~/.kube -name 'config*' | sort | tr '\n' ':')${default}"
      kill -INT $$
    fi
  fi
}

check_dependencies
check_version
verify_path
verify_symlink
verify_kubeconfig

PS3="${cyan}Select an option: $gold"
options=("Switch context" "Manage kubectl versions" "Get config from lastpass" "Configure KTX")
select opt in "${options[@]}"; do
  case $opt in
    "Switch context")
      switch_context
      break
      ;;
    "Manage kubectl versions")
      kubectl_manage
      break
      ;;
    "Get config from lastpass")
      kubectl_pull
      break
      ;;
    "Configure KTX")
      setup_profile
      break
      ;;
    "")
      echo "${red}Invalid Option ${magenta}CTL + C to quit${default}"
      ;;
  esac
done
